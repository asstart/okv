---

title: 01. Introduction
layout: default
parent: Scala with cats
grand_parent: Books log

---

## Type classes

*   traits: type classes;
*   implicit values: type class instances;
*   implicit parameters: type class use; and
*   implicit classes: optional utilities that make type classes easier to use.

#### Type class

> *Type class* - A type class is an interface or API that represents some functionality we want to implement. In Scala, a type class is represented by a trait with at least one type parameter.

```scala
// Define a very simple JSON AST  
sealed trait Json  
final case class JsObject(get: Map[String, Json]) extends Json  
final case class JsString(get: String) extends Json  
final case class JsNumber(get: Double) extends Json  
final case object JsNull extends Json

// The "serialize to JSON" behaviour is encoded in this trait
// JsonWriter is a type class
trait JsonWriter[A] {  
	def write(value: A): Json
}
```

#### Type class instance

> *Type class instances* - implementations of the type class for specific types we care about, which can include types from the Scala standard library and types from our domain model.

```scala
object JsonWriterInstances {  
	implicit val stringWriter: JsonWriter[String] =  
		new JsonWriter[String] {  
		def write(value: String): Json =  
		JsString(value)  
	}  
}
```

#### Type class use

A *type class use* is any functionality that requires a type class instance to work.

##### Interface Objects

```scala
final case class Person(name: String, email: String)  
object JsonWriterInstances {  
  
	implicit val personWriter: JsonWriter[Person] =  
		new JsonWriter[Person] {  
			def write(value: Person): Json =  
				JsObject(Map(  
					"name" -> JsString(value.name),  
					"email" -> JsString(value.email)  
				))  
		} 
}
```

```scala
object Json {  
	def toJson[A](value: A)(implicit w: JsonWriter[A]): Json =  
		w.write(value)  
}
```

```scala
import JsonWriterInstances._  

Json.toJson(Person("Dave", "dave@example.com"))  
// eq to Json.toJson(Person("Dave", "dave@example.com"))(personWriter)
```

##### Interface Syntax

We can alternatively use extension methods to extend existing types with interface methods.

```scala
object JsonSyntax {  
	implicit class JsonWriterOps[A](value: A) {  
		def toJson(implicit w: JsonWriter[A]): Json =  
			w.write(value)  
	}  
}
```

```scala
import JsonWriterInstances._  
import JsonSyntax._  

Person("Dave", "dave@example.com").toJson  
```

#### Working with implicits

> *Implicit scope* - the places where the compiler searches for candidate instances.

Places for searching implicits:

*   local or inherited definitions
*   imported definitions
*   definitions in the companion object of the type class or the parameter type (in this case JsonWriter or String)

##### Recursive Implicit Resolution or type class composition

In addition to defining implicit instances with `val` keyword, we can also define *implicit methods* which can construct required implicit instances. It can be useful in case if we need implicit argument with type like `JsonWriter[Option[A]]`, so now instead making single implicit instance like `JsonWriter[String]` we also need to create additional implicit instance `JsonWriter[Option[String]]` and that we need to do for each type. Here implicit methods can help us. Instead of creating additional implicit instance for `Option[A]` for each type, we can define following implicit method:

```scala
implicit def optionWriter[A](implicit writer: JsonWriter[A]): JsonWriter[Option[A]] =  
	new JsonWriter[Option[A]] {  
		def write(option: Option[A]): Json =  
			option match {  
			case Some(aValue) => writer.write(aValue)  
			case None => JsNull  
		}  
	}
```

In this way, implicit resolution becomes a search through the space of possible\
combinations of implicit definitions, to find a combination that creates a type\
class instance of the correct overall type.

## Meet Cats

#### Type Class: Show

[Documentation](https://typelevel.org/cats/typeclasses/show.html)\
Useful imports:

```scala
// Helper func. ions to create implementation for a custom case class
import cats.Show

// Extension methods to use show as [obj.show]
import cats.syntax.show._
```

Show is an alternative to the Java `toString` method. The difference is that `toString` is defined on `Any`(Java's `Object`) and can therefore be called on anything, not just case classes. Most often, this is unwanted behavior, as the standard implementation of `toString` on non case classes is mostly gibberish.

To implement `Show` for a custom case class, cats offer 2 helper functions:

```scala
/** creates an instance of Show using the provided function */
def show[A](f: A => String): Show[A]

/** creates an instance of Show using object toString */
def fromToString[A]: Show[A]
```

Example:

```scala
final case class Cat(name: String, age: Int, color: String)

object Cat {
	import cats.Show
	import cats.syntax.show._
	
	implicit val showCat: Show[Cat] = Show.show((value: Cat) => s"${value.name.show} is a ${value.age.show} year-old ${value.color.show} cat.")
}
```

Usage:

```scala
import cats.syntax.show._

Cat("cat", 10, "black").show
```

#### Type Class: Eq

[Documentation](https://typelevel.org/cats/typeclasses/eq.html)\
Useful imports

```scala
// To test obj equality by using operators [===] or [=!=]
import cats.syntax.eq_
```

Goal of `Eq` type class to add type safety to object comparison as Java standard equality operator `==` can compare any two object, and we can write following code `1 == Some(1)` which will be always false, because we compare `Int` with `Some[Int]`. So `Eq` is solving this problem by type class:

```scala
trait Eq[A] {  
	def eqv(a: A, b: A): Boolean  
}
```

Simple compare:

```scala
import cats.syntax.eq._
import cats.instances.int.

// true
123 === 123

// false
124 =!= 123

// compile error
123 === "123"
```

Compare options:

```scala
import cats.syntax.option._
import cats.syntax.eq._
import cats.instances.int._
import cats.instances.option._

// compile error
Some(1) === None

// false
(Some(1) : Option[Int]) === (None : Option[Int])

// false
Option(1) === Option.empty[Int]

// false
1.some === none[Int]

// true
1.some =!= none[Int]
```

### Controlling Instance Selection

There are 2 common questions here:

1.  What is the relationships between an instance defined on a type and its subtypes? If we defined an instance of type `JsonWriter[Option[Int]]` will it be selected for expression `Json.toJson(Some(1))` or not?
2.  How to choose between type class instances if many are available?

Behavior table

| Type Class Variance          | Invariant | Covariant | Contrvariant |
| ---------------------------- | --------- | --------- | ------------ |
| Supertype Instance Used?     | -         | -         | +            |
| More Specific Type Prefered? | -         | +         | -            |
